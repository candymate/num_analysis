
# This file was *autogenerated* from the file ./4_5_1.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_0p0 = RealNumber('0.0'); _sage_const_10 = Integer(10); _sage_const_0p5 = RealNumber('0.5')#!/usr/local/bin/sage

# A slight modification in algorithm 4.2 in textbook

# a
f = (x**_sage_const_2 )*(e**(-x))
a = _sage_const_0 
b = _sage_const_1 

# b
#f = (x^2)*ln(x)
#a = 1
#b = 1.5

h = b - a
R = [((h / _sage_const_2 )*(f(a) + f(b))).n()]

prev = _sage_const_0p0 

for i in xrange(_sage_const_9 ):
  #print R
  print (i + _sage_const_1 ), ":", R[i]
  
  if i > _sage_const_0  and abs(R[i] - prev) < _sage_const_10 **(-_sage_const_6 ):
    print "done : ", (i + _sage_const_1 )
    print "exact val : ", numerical_integral(f, a, b)
    print "abs error : ", abs(numerical_integral(f, a, b)[_sage_const_0 ] - R[i])
    break
  
  prev = R[i]
  
  res = _sage_const_0p0 
  for k in xrange(_sage_const_1 , _sage_const_2 **i + _sage_const_1 ):
    res += f(a + (k - _sage_const_0p5 )*h).n()
  R2 = [((_sage_const_1 /_sage_const_2 )*(R[_sage_const_0 ] + h * res)).n()]
  
  for j in xrange(_sage_const_1 , i + _sage_const_2 ):
    R2.append(R2[j - _sage_const_1 ] + (R2[j - _sage_const_1 ] - R[j - _sage_const_1 ]) / (_sage_const_4 **(j) - _sage_const_1 ))
  
  h = h / _sage_const_2 
  R = R2


